//
//  Router.swift
//  ZeroHTTP
//
//  Created by Philipp Kotte on 03.07.25.
//

import Foundation
import ZeroErrors
import ZeroLogger

/// A thread-safe router that manages and dispatches requests to registered routes.
public final class Router: @unchecked Sendable {
    
    private var logger: Logger = Logger(label: "zero.http.router")
    /// The shared singleton instance, allowing global access to the router.
    public static let shared = Router()
    
    // A private lock to protect concurrent access to the `_routes` array.
    private let lock = NSLock()
    
    // The internal storage for routes. Access must be synchronized.
    private var _routes: [Route] = []
    
    /// A thread-safe computed property to get the routes.
    public var routes: [Route] {
        lock.lock()
        defer { lock.unlock() }
        return _routes
    }
    
    /// A private initializer to enforce the singleton pattern.
    private init() {}
    
    /// Registers all routes from a given controller in a thread-safe manner.
    /// - Parameter controller: The controller whose routes should be registered.
    public func register(controller: Controller) {
        lock.lock()
        defer { lock.unlock() }
        self._routes.append(contentsOf: controller.body)
    }
    
    /// Handles an incoming request by finding a matching route and executing its handler.
    ///
    /// This method supports both exact path matching and wildcard matching (e.g., "/public/*").
    /// It is thread-safe, creating a local copy of the routes to iterate over.
    ///
    /// - Parameter request: The `HttpRequest` object to handle.
    /// - Returns: An `HttpResponse` generated by the matched route's handler, or a 404 response.
    public func handle(request: HttpRequest, _ globalMiddlewares: [Middleware]) -> HttpResponse {
        // Create a local, thread-safe copy of the routes to iterate over.
        // This minimizes the time the lock is held.
        let currentRoutes = self.routes
        
        for route in currentRoutes {
            logger.dev("CurrentRoute \(route)")
            
            // Wildcard matching for paths ending in "*"
            if route.path.hasSuffix("*") {
                let prefix = route.path.dropLast()
                if request.path.hasPrefix(prefix) {
                    return route.handler(request)
                }
            }
            // Exact path matching
            else if route.path == request.path {
                var requestWithMetaData = request
                requestWithMetaData.metadata = route.metadata
                self.logger.info("Metadata gesetzt für route \(route.path) -> \(route.metadata) = \(requestWithMetaData.metadata)")
                
                // 3. Der "finale Responder" ist der Handler der gefundenen Route.
                let finalResponder: Responder = { req in
                    return route.handler(req)
                }
                
                // 4. Erstelle die Middleware-Kette mit den globalen Middlewares.
                //    Routen-spezifische Middlewares könnten hier ebenfalls hinzugefügt werden.
                let chain = MiddlewareChain(middlewares: globalMiddlewares, responder: finalResponder)
                
                // 5. Führe die Kette mit der angereicherten Anfrage aus.
                return chain.run(request: requestWithMetaData)
            }
            
            return notFoundResponse()
        }
        
        // If no route was matched, return a standard 404 response.
        let body = resourceNotFound
        var headers = HttpHeaders()
        headers["Content-Type"] = "text/html; charset=utf-8"
        
        return HttpResponse(status: .notFound, statusPhrase: "Not Found", headers: headers, body: body.data(using: .utf8))
    }
}
